@startuml
'https://plantuml.com/class-diagram

abstract class AbstractFlyingObject
{
    # int locationX
    # int locationY
    # int speedX
    # int speedY
    # BufferedImage image
    # int width
    # int height
    # boolean isValid

    + FlyingObject(int locationX, int locationY, int speedX, int speedY):void
    + {abstract} forward():void
    + crash(FlyingObject flyingObject):boolean
    + setLocation(double locationX, double locationY):void
    + getLocationX():int
    + getLocationY():int
    + getSpeedY():int
    + getImage():BufferedImage
    + getWidth():int
    + getHeight():int
    + notValid():boolean
    + vanish():void
}
abstract class AbstractAircraft
{
	# int maxHp
    # int hp
    + AbstractAircraft(int locationX, int locationY, int speedX, int speedY, int hp):void
    + decreaseHp(int decrease):void
    + getHp():int
    + {abstract} forward():void
    + {abstract} shoot():List<Bullet>
 }

abstract class BaseBullet
{
    - int power
    + Bullet(int locationX, int locationY, int speedX, int speedY, int power):void
    + forward():void
	+ getPower():int
}
abstract class AbstractProp{
    +forward():void
    +AbstractProp(int locationX,int locationY):void
    +{abstract} propDo(HeroAircraft heroAircraft,List<AbstractAircraft> enemy):void

}


AbstractFlyingObject <|-- AbstractAircraft
AbstractFlyingObject <|-- BaseBullet
AbstractFlyingObject <|-- AbstractProp

AbstractAircraft <|-- HeroAircraft
AbstractAircraft <|-- MobEnemy
AbstractAircraft <|-- EliteEnemy
'AbstractAircraft <|-- BossEnemy

BaseBullet <|-- HeroBullet
BaseBullet <|-- EnemyBullet

AbstractProp <|-- PropBlood
AbstractProp <|-- PropBomb
AbstractProp <|-- PropBullet



class HeroAircraft {
    - int shootNum
    - int power
    - int direction
    - HeroAircraft heroAircraft  '唯一的英雄机类的该类的静态对象
    - HeroAircraft(int locationX, int locationY, int speedX, int speedY, int hp):HeroAircraft   '构造方法私有化，使得外界不能够通过构造方法生成更多变量
    + getHeroAircraft():HeroAircraft   '唯一提供给外界的用来访问类唯一静态英雄机变量的方法
    + forward():void
    + shoot():List<Bullet>
}



class MobEnemy {
    - int shootNum
    - int power
    - int direction
    + MobEnemy(int locationX, int locationY, int speedX, int speedY, int hp):MobEnemy
    + forward():void
    + shoot():List<Bullet>
}

class EliteEnemy{
    - int shootNum
    - int power
    - int direction
    + EliteEnemy(int locationX, int locationY):EliteEnemy
    + forward():void
    + shoot():List<Bullet>
}

class BossEnemy{
    - int shootNum
    - int power
    - int direction
    + EliteEnemy(int locationX, int locationY):void
    + forward():void
    + shoot():List<Bullet>
}

class HeroBullet {
    + HeroBullet(int locationX, int locationY,
     int speedX, int speedY, int power):void
}

class EnemyBullet {
    + EnemyBullet(int locationX, int locationY,
     int speedX, int speedY, int power):void
}


class PropBlood {
    +forward():void
    +PropBlood(int locationX,int locationY):void
    +propDo(HeroAircraft heroAircraft,List<AbstractAircraft> enemy):void
}

class PropBomb {
    +forward():void
    +PropBomb(int locationX,int locationY):void
    +propDo(HeroAircraft heroAircraft,List<AbstractAircraft> enemy):void
}

class PropBullet {
    +forward():void
    +PropBullet(int locationX,int locationY):void
    +propDo(HeroAircraft heroAircraft,List<AbstractAircraft> enemy):void
}

'抽象工厂方法相关工厂接口和产品接口


interface AbstractPropFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}

interface AbstractAircraftFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}

interface FlyingObjectProduct {

}



'工厂接口依赖于产品接口
FlyingObjectProduct <.. AbstractPropFactory
FlyingObjectProduct <.. AbstractAircraftFactory

'实现工厂接口的各个具体工厂
class MobEnemyFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}
class EliteEnemyFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}
class BossEnemyFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}

class PropBloodFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}
class PropBulletFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}
class PropBombFactory {
    +produceFlyingObjectProduct():FlyingObjectProduct
}

'需要让所有道具类飞机类都实现产品接口，所以让他们的共同抽象父类实现产品接口
FlyingObjectProduct <|.. AbstractFlyingObject

'描述实现工厂接口的具体工厂类型与工厂接口之间的实现关系
AbstractAircraftFactory <|.. MobEnemyFactory
AbstractAircraftFactory <|.. EliteEnemyFactory
AbstractAircraftFactory <|.. BossEnemyFactory
AbstractPropFactory <|.. PropBloodFactory
AbstractPropFactory <|.. PropBulletFactory
AbstractPropFactory <|.. PropBombFactory

'描述具体的工厂与他们要生产的具体产品类型之间的依赖关系，因为他们的生产方法依赖用到特定类型的构造方法
MobEnemy <.. MobEnemyFactory
EliteEnemy <.. EliteEnemyFactory
BossEnemy <.. BossEnemyFactory
PropBlood <.. PropBloodFactory
PropBullet <..PropBulletFactory
PropBomb <.. PropBombFactory



@enduml